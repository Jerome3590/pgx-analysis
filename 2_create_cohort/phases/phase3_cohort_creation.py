"""
Phase 3: Final Cohort Creation with 5:1 ratio and DuckDB optimizations.

Creates OPIOID_ED and ED_NON_OPIOID cohorts with target and control groups.
"""

from .common import (
    datetime,
    SYMBOLS,
    cleanup_duckdb_temp_files,
    enable_query_profiling,
    disable_query_profiling,
    force_checkpoint,
    execute_sql_with_dev_validation,
    ensure_gold_views,
    ensure_unified_views,
)
from helpers_1997_13.constants import S3_BUCKET
import os


def run_phase3_step3_final_cohort_fact(context):
    """Phase 3 Step 3: Final Cohort Creation with 5:1 ratio and DuckDB optimizations."""
    logger = context["logger"]
    cohort_conn_duckdb = context["cohort_conn_duckdb"]
    age_band = context["age_band"]
    event_year = context["event_year"]
    pipeline_state = context.get("pipeline_state")
    
    step_name = "phase3_step3_final_cohort_fact"
    
    # Check if step already completed
    if pipeline_state and pipeline_state.is_step_completed(step_name):
        logger.info(f"{SYMBOLS['success']} [PHASE 3 STEP 3] Already completed - skipping")
        return
    
    logger.info(f"{SYMBOLS['arrow']} [PHASE 3 STEP 3] Starting optimized final cohort creation (5:1 ratio)...")
    
    try:
        # Ensure required views exist if earlier phases were skipped
        ensure_gold_views(cohort_conn_duckdb, logger, age_band, event_year)
        ensure_unified_views(cohort_conn_duckdb, logger)

        # Determine classification labels based on dynamic targeting env
        target_icd = os.getenv("PGX_TARGET_ICD_CODES", "").strip() or os.getenv("PGX_TARGET_ICD_PREFIXES", "").strip()
        target_cpt = os.getenv("PGX_TARGET_CPT_CODES", "").strip() or os.getenv("PGX_TARGET_CPT_PREFIXES", "").strip()
        dynamic_targeting = bool(target_icd or target_cpt)
        label_target = 'target' if dynamic_targeting else 'opioid_ed'
        # ED_NON_OPIOID always uses 'ed_non_opioid' because HCG ED visits are always classified as 'ed_non_opioid'
        # regardless of dynamic targeting (see Phase 2 classification logic)
        label_ed_non_opioid = 'ed_non_opioid'
        # Enable query profiling for this step
        enable_query_profiling(cohort_conn_duckdb, logger, "json", f"/tmp/duckdb_profiling_phase3_step3_final_cohort_fact.json")
        
        # Check target case counts BEFORE creating cohorts
        target_case_count = cohort_conn_duckdb.sql(f"""
        SELECT COUNT(DISTINCT mi_person_key) 
        FROM unified_event_fact_table
        WHERE event_classification = '{label_target}'
        """).fetchone()[0]
        
        # Count ED_NON_OPIOID targets AFTER excluding opioid patients
        from helpers_1997_13.constants import OPIOID_ICD_CODES
        ed_non_opioid_case_count_query = f"""
        WITH opioid_patients AS (
            SELECT DISTINCT mi_person_key
            FROM unified_event_fact_table
            WHERE primary_icd_diagnosis_code IN {tuple(OPIOID_ICD_CODES)}
        )
        SELECT COUNT(DISTINCT mi_person_key) 
        FROM unified_event_fact_table
        WHERE event_classification = '{label_ed_non_opioid}'
          AND mi_person_key NOT IN (SELECT mi_person_key FROM opioid_patients)
        """
        ed_non_opioid_case_count = cohort_conn_duckdb.sql(ed_non_opioid_case_count_query).fetchone()[0]
        
        logger.info(f"→ [PHASE 3 STEP 3] Target case counts:")
        logger.info(f"  OPIOID_ED target patients ({label_target}): {target_case_count:,}")
        logger.info(f"  ED_NON_OPIOID target patients ({label_ed_non_opioid}): {ed_non_opioid_case_count:,}")
        
        if target_case_count == 0:
            logger.warning(f"⚠️ [PHASE 3 STEP 3] WARNING: No target cases found for OPIOID_ED cohort ({label_target})")
            logger.warning(f"   Cohort will be empty and will not be saved to S3")
            logger.warning(f"   Check: Are target ICD codes present in {age_band}/{event_year}?")
        
        if ed_non_opioid_case_count == 0:
            logger.warning(f"⚠️ [PHASE 3 STEP 3] WARNING: No target cases found for ED_NON_OPIOID cohort ({label_ed_non_opioid})")
            logger.warning(f"   Will create control-only cohort for model training consistency")
        
        # Load pre-computed average target count for control-only cohorts
        # This avoids recalculating averages at runtime for each partition
        # Config is generated by step1_pre_cohort_audit.py and saved to S3 and local file
        avg_target_count = None
        if target_case_count == 0 or ed_non_opioid_case_count == 0:
            import json
            import boto3
            
            # Try loading from local config file first (faster)
            config_file = os.path.join(os.path.dirname(__file__), '..', '..', 'cohort_target_averages.json')
            config = None
            
            try:
                if os.path.exists(config_file):
                    with open(config_file, 'r') as f:
                        config = json.load(f)
                    logger.info(f"→ [PHASE 3 STEP 3] Loaded pre-computed averages from local config")
                else:
                    # Try loading from S3 if local file doesn't exist
                    logger.info(f"→ [PHASE 3 STEP 3] Local config not found, trying S3...")
                    s3_path = f"s3://{S3_BUCKET}/gold/qa_results/pre_cohort_audit/target_averages.json"
                    try:
                        s3_client = boto3.client('s3')
                        bucket = S3_BUCKET
                        key = "gold/qa_results/pre_cohort_audit/target_averages.json"
                        response = s3_client.get_object(Bucket=bucket, Key=key)
                        config = json.loads(response['Body'].read().decode('utf-8'))
                        logger.info(f"→ [PHASE 3 STEP 3] Loaded pre-computed averages from S3")
                        # Save locally for future use
                        try:
                            with open(config_file, 'w') as f:
                                json.dump(config, f, indent=2)
                            logger.info(f"→ [PHASE 3 STEP 3] Saved S3 config to local file for future use")
                        except Exception:
                            pass
                    except Exception as s3_e:
                        logger.warning(f"⚠️ Could not load from S3: {s3_e}")
                        logger.warning(f"   Run step1_pre_cohort_audit.py --save-results first")
            except Exception as e:
                logger.warning(f"⚠️ Could not load pre-computed averages: {e}")
                config = None
            
            # Extract average from config
            if config and 'averages' in config and 'combined' in config['averages']:
                avg_target_count = int(config['averages']['combined']['average'])
                logger.info(f"→ [PHASE 3 STEP 3] Using pre-computed average combined targets: {avg_target_count:,}")
            else:
                # Fallback to reasonable default if config not available
                avg_target_count = 1000  # Default fallback
                logger.warning(f"⚠️ [PHASE 3 STEP 3] Using fallback average target count: {avg_target_count:,}")
                logger.warning(f"   Run step1_pre_cohort_audit.py --save-results to generate proper averages")
        
        # Create OPIOID_ED cohort with 5:1 control-to-target ratio
        # If no targets, create control-only cohort using average target count
        if target_case_count > 0:
            # Normal case: has targets
            opioid_ed_cohort_sql = f"""
            CREATE OR REPLACE VIEW opioid_ed_cohort AS
            WITH target_cases AS (
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE event_classification = '{label_target}'
            ),
            control_candidates AS (
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE event_classification != '{label_target}'
                  AND mi_person_key NOT IN (SELECT mi_person_key FROM target_cases)
            ),
            sampled_controls AS (
                SELECT mi_person_key
                FROM control_candidates
                ORDER BY RANDOM()
                LIMIT (SELECT COUNT(*) * 5 FROM target_cases)
            )
            SELECT 
                uef.*,
                1 as target,
                'OPIOID_ED' as cohort_name,
                CASE 
                    WHEN tc.mi_person_key IS NOT NULL THEN 'OPIOID_ED'
                    ELSE 'NON_ED'
                END as cohort,
                CASE WHEN tc.mi_person_key IS NOT NULL THEN 1 ELSE 0 END as is_target_case
            FROM unified_event_fact_table uef
            LEFT JOIN target_cases tc ON uef.mi_person_key = tc.mi_person_key
            LEFT JOIN sampled_controls sc ON uef.mi_person_key = sc.mi_person_key
            WHERE tc.mi_person_key IS NOT NULL OR sc.mi_person_key IS NOT NULL;
            """
        else:
            # Zero targets: create control-only cohort
            logger.info(f"→ [PHASE 3 STEP 3] Creating control-only OPIOID_ED cohort (no targets found)")
            control_limit = avg_target_count * 5 if avg_target_count else 5000  # Default 5000 controls
            opioid_ed_cohort_sql = f"""
            CREATE OR REPLACE VIEW opioid_ed_cohort AS
            WITH control_candidates AS (
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE event_classification != '{label_target}'
            ),
            sampled_controls AS (
                SELECT mi_person_key
                FROM control_candidates
                ORDER BY RANDOM()
                LIMIT {control_limit}
            )
            SELECT 
                uef.*,
                0 as target,  -- All controls, no targets
                'OPIOID_ED' as cohort_name,
                'NON_ED' as cohort,  -- All controls are non-ED
                0 as is_target_case  -- All are controls
            FROM unified_event_fact_table uef
            INNER JOIN sampled_controls sc ON uef.mi_person_key = sc.mi_person_key;
            """
        execute_sql_with_dev_validation(cohort_conn_duckdb, logger, opioid_ed_cohort_sql)
        logger.info("→ [PHASE 3 STEP 3] OPIOID_ED cohort created")
        
        # Create ED_NON_OPIOID cohort with 5:1 control-to-target ratio
        # Target cases are HCG-based ED visits (always classified as 'ed_non_opioid')
        # EXCLUDE patients with opioid ICD codes (F1120, etc.) from target cases
        # If no targets, create control-only cohort using average target count
        if ed_non_opioid_case_count > 0:
            # Normal case: has targets
            # Exclude patients who have opioid ICD codes from ED_NON_OPIOID target cases
            from helpers_1997_13.constants import OPIOID_ICD_CODES
            ed_non_opioid_cohort_sql = f"""
            CREATE OR REPLACE VIEW ed_non_opioid_cohort AS
            WITH opioid_patients AS (
                -- Patients with opioid ICD codes (F1120, etc.) - exclude from ED_NON_OPIOID targets
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE primary_icd_diagnosis_code IN {tuple(OPIOID_ICD_CODES)}
            ),
            target_cases AS (
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE event_classification = '{label_ed_non_opioid}'
                  AND mi_person_key NOT IN (SELECT mi_person_key FROM opioid_patients)
            ),
            control_candidates AS (
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE event_classification != '{label_ed_non_opioid}'
                  AND mi_person_key NOT IN (SELECT mi_person_key FROM target_cases)
                  AND mi_person_key NOT IN (SELECT mi_person_key FROM opioid_patients)
                  -- Exclude opioid patients from controls as well - complete separation
            ),
            sampled_controls AS (
                SELECT mi_person_key
                FROM control_candidates
                ORDER BY RANDOM()
                LIMIT (SELECT COUNT(*) * 5 FROM target_cases)
            )
            SELECT 
                uef.*,
                1 as target,
                'ED_NON_OPIOID' as cohort_name,
                CASE 
                    WHEN tc.mi_person_key IS NOT NULL THEN 'NON_OPIOID_ED'
                    WHEN uef.event_type = 'medical' AND uef.hcg_line IS NULL THEN 'NON_ED'
                    ELSE 'NON_ED'
                END as cohort,
                CASE WHEN tc.mi_person_key IS NOT NULL THEN 1 ELSE 0 END as is_target_case
            FROM unified_event_fact_table uef
            LEFT JOIN target_cases tc ON uef.mi_person_key = tc.mi_person_key
            LEFT JOIN sampled_controls sc ON uef.mi_person_key = sc.mi_person_key
            WHERE tc.mi_person_key IS NOT NULL OR sc.mi_person_key IS NOT NULL;
            """
        else:
            # Zero targets: create control-only cohort
            logger.info(f"→ [PHASE 3 STEP 3] Creating control-only ED_NON_OPIOID cohort (no targets found)")
            control_limit = avg_target_count * 5 if avg_target_count else 5000  # Default 5000 controls
            # Exclude opioid patients from controls as well
            from helpers_1997_13.constants import OPIOID_ICD_CODES
            ed_non_opioid_cohort_sql = f"""
            CREATE OR REPLACE VIEW ed_non_opioid_cohort AS
            WITH opioid_patients AS (
                -- Patients with opioid ICD codes (F1120, etc.) - exclude from ED_NON_OPIOID entirely
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE primary_icd_diagnosis_code IN {tuple(OPIOID_ICD_CODES)}
            ),
            control_candidates AS (
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE event_classification != '{label_ed_non_opioid}'
                  AND mi_person_key NOT IN (SELECT mi_person_key FROM opioid_patients)
            ),
            sampled_controls AS (
                SELECT mi_person_key
                FROM control_candidates
                ORDER BY RANDOM()
                LIMIT {control_limit}
            )
             SELECT 
                 uef.*,
                 0 as target,  -- All controls, no targets
                 'ED_NON_OPIOID' as cohort_name,
                 'NON_ED' as cohort,  -- All controls are non-ED
                 0 as is_target_case  -- All are controls
             FROM unified_event_fact_table uef
            INNER JOIN sampled_controls sc ON uef.mi_person_key = sc.mi_person_key;
            """
        execute_sql_with_dev_validation(cohort_conn_duckdb, logger, ed_non_opioid_cohort_sql)
        logger.info("→ [PHASE 3 STEP 3] ED_NON_OPIOID cohort created")
        
        # QA checks
        opioid_ed_count = cohort_conn_duckdb.sql("SELECT COUNT(*) FROM opioid_ed_cohort").fetchone()[0]
        ed_non_opioid_count = cohort_conn_duckdb.sql("SELECT COUNT(*) FROM ed_non_opioid_cohort").fetchone()[0]
        
        # Check control ratios
        opioid_ed_ratio = cohort_conn_duckdb.sql("""
        SELECT 
            COUNT(DISTINCT CASE WHEN is_target_case = 1 THEN mi_person_key END) as target_cases,
            COUNT(DISTINCT CASE WHEN is_target_case = 0 THEN mi_person_key END) as control_cases
        FROM opioid_ed_cohort
        """).fetchone()
        
        ed_non_opioid_ratio = cohort_conn_duckdb.sql("""
        SELECT 
            COUNT(DISTINCT CASE WHEN is_target_case = 1 THEN mi_person_key END) as target_cases,
            COUNT(DISTINCT CASE WHEN is_target_case = 0 THEN mi_person_key END) as control_cases
        FROM ed_non_opioid_cohort
        """).fetchone()
        
        opioid_ed_control_ratio = opioid_ed_ratio[1] / opioid_ed_ratio[0] if opioid_ed_ratio[0] > 0 else 0
        ed_non_opioid_control_ratio = ed_non_opioid_ratio[1] / ed_non_opioid_ratio[0] if ed_non_opioid_ratio[0] > 0 else 0
        
        logger.info(f"→ [PHASE 3 STEP 3] QA: OPIOID_ED records: {opioid_ed_count:,}")
        logger.info(f"→ [PHASE 3 STEP 3] QA: ED_NON_OPIOID records: {ed_non_opioid_count:,}")
        logger.info(f"→ [PHASE 3 STEP 3] QA: OPIOID_ED control ratio: {opioid_ed_control_ratio:.2f}:1")
        logger.info(f"→ [PHASE 3 STEP 3] QA: ED_NON_OPIOID control ratio: {ed_non_opioid_control_ratio:.2f}:1")
        
        # F1120-specific checks in cohorts
        f1120_opioid_check = cohort_conn_duckdb.sql("""
        SELECT 
            COUNT(*) as total_f1120_records,
            COUNT(DISTINCT mi_person_key) as distinct_f1120_patients,
            COUNT(DISTINCT CASE WHEN is_target_case = 1 THEN mi_person_key END) as f1120_target_patients,
            COUNT(DISTINCT CASE WHEN is_target_case = 0 THEN mi_person_key END) as f1120_control_patients
        FROM opioid_ed_cohort
        WHERE primary_icd_diagnosis_code = 'F1120'
        """).fetchone()
        
        f1120_ed_non_opioid_check = cohort_conn_duckdb.sql("""
        SELECT 
            COUNT(*) as total_f1120_records,
            COUNT(DISTINCT mi_person_key) as distinct_f1120_patients,
            COUNT(DISTINCT CASE WHEN is_target_case = 1 THEN mi_person_key END) as f1120_target_patients,
            COUNT(DISTINCT CASE WHEN is_target_case = 0 THEN mi_person_key END) as f1120_control_patients
        FROM ed_non_opioid_cohort
        WHERE primary_icd_diagnosis_code = 'F1120'
        """).fetchone()
        
        logger.info(f"→ [PHASE 3 STEP 3] F1120 IN OPIOID_ED COHORT:")
        logger.info(f"  Total F1120 records: {f1120_opioid_check[0]:,}")
        logger.info(f"  Distinct F1120 patients: {f1120_opioid_check[1]:,}")
        logger.info(f"  F1120 target patients: {f1120_opioid_check[2]:,}")
        logger.info(f"  F1120 control patients: {f1120_opioid_check[3]:,}")
        
        logger.info(f"→ [PHASE 3 STEP 3] F1120 IN ED_NON_OPIOID COHORT:")
        logger.info(f"  Total F1120 records: {f1120_ed_non_opioid_check[0]:,}")
        logger.info(f"  Distinct F1120 patients: {f1120_ed_non_opioid_check[1]:,}")
        logger.info(f"  F1120 target patients: {f1120_ed_non_opioid_check[2]:,}")
        logger.info(f"  F1120 control patients: {f1120_ed_non_opioid_check[3]:,}")
        
        # Force checkpoint
        force_checkpoint(cohort_conn_duckdb, logger)
        
        # Disable query profiling
        disable_query_profiling(cohort_conn_duckdb, logger)
        
        # Save checkpoint
        if pipeline_state:
            pipeline_state.mark_step_completed(step_name, {
                'opioid_ed_count': opioid_ed_count,
                'ed_non_opioid_count': ed_non_opioid_count,
                'opioid_ed_control_ratio': float(opioid_ed_control_ratio),
                'ed_non_opioid_control_ratio': float(ed_non_opioid_control_ratio),
                'timestamp': datetime.now().isoformat()
            })
        
        logger.info(f"{SYMBOLS['success']} [PHASE 3 STEP 3] Optimized final cohort creation completed")
        
    except Exception as e:
        logger.error(f"{SYMBOLS['fail']} [PHASE 3 STEP 3] Final cohort creation failed: {str(e)}")
        if pipeline_state:
            pipeline_state.mark_step_failed(step_name, str(e))
        cleanup_duckdb_temp_files(logger)
        raise

