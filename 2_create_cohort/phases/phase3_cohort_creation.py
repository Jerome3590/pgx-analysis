"""
Phase 3: Final Cohort Creation with 5:1 ratio and DuckDB optimizations.

Creates OPIOID_ED and ED_NON_OPIOID cohorts with target and control groups.
"""

from .common import (
    datetime,
    SYMBOLS,
    cleanup_duckdb_temp_files,
    enable_query_profiling,
    disable_query_profiling,
    force_checkpoint,
    execute_sql_with_dev_validation,
    ensure_gold_views,
    ensure_unified_views,
)
from helpers_1997_13.constants import S3_BUCKET
import os


def run_phase3_step3_final_cohort_fact(context):
    """Phase 3 Step 3: Final Cohort Creation with 5:1 ratio and DuckDB optimizations."""
    logger = context["logger"]
    cohort_conn_duckdb = context["cohort_conn_duckdb"]
    age_band = context["age_band"]
    event_year = context["event_year"]
    pipeline_state = context.get("pipeline_state")
    
    step_name = "phase3_step3_final_cohort_fact"
    
    # Check if step already completed
    if pipeline_state and pipeline_state.is_step_completed(step_name):
        logger.info(f"{SYMBOLS['success']} [PHASE 3 STEP 3] Already completed - skipping")
        return
    
    logger.info(f"{SYMBOLS['arrow']} [PHASE 3 STEP 3] Starting optimized final cohort creation (5:1 ratio)...")
    
    try:
        # Ensure required views exist if earlier phases were skipped
        ensure_gold_views(cohort_conn_duckdb, logger, age_band, event_year)
        ensure_unified_views(cohort_conn_duckdb, logger)

        # Determine classification labels based on dynamic targeting env
        target_icd = os.getenv("PGX_TARGET_ICD_CODES", "").strip() or os.getenv("PGX_TARGET_ICD_PREFIXES", "").strip()
        target_cpt = os.getenv("PGX_TARGET_CPT_CODES", "").strip() or os.getenv("PGX_TARGET_CPT_PREFIXES", "").strip()
        dynamic_targeting = bool(target_icd or target_cpt)
        label_target = 'target' if dynamic_targeting else 'opioid_ed'
        # ED_NON_OPIOID always uses 'ed_non_opioid' because HCG ED visits are always classified as 'ed_non_opioid'
        # regardless of dynamic targeting (see Phase 2 classification logic)
        label_ed_non_opioid = 'ed_non_opioid'
        # Enable query profiling for this step
        enable_query_profiling(cohort_conn_duckdb, logger, "json", f"/tmp/duckdb_profiling_phase3_step3_final_cohort_fact.json")
        
        # Check target case counts BEFORE creating cohorts
        target_case_count = cohort_conn_duckdb.sql(f"""
        SELECT COUNT(DISTINCT mi_person_key) 
        FROM unified_event_fact_table
        WHERE event_classification = '{label_target}'
        """).fetchone()[0]
        
        # Count ED_NON_OPIOID targets AFTER excluding opioid patients
        from helpers_1997_13.constants import OPIOID_ICD_CODES
        ed_non_opioid_case_count_query = f"""
        WITH opioid_patients AS (
            SELECT DISTINCT mi_person_key
            FROM unified_event_fact_table
            WHERE primary_icd_diagnosis_code IN {tuple(OPIOID_ICD_CODES)}
        )
        SELECT COUNT(DISTINCT mi_person_key) 
        FROM unified_event_fact_table
        WHERE event_classification = '{label_ed_non_opioid}'
          AND mi_person_key NOT IN (SELECT mi_person_key FROM opioid_patients)
        """
        ed_non_opioid_case_count = cohort_conn_duckdb.sql(ed_non_opioid_case_count_query).fetchone()[0]
        
        logger.info(f"→ [PHASE 3 STEP 3] Target case counts:")
        logger.info(f"  OPIOID_ED target patients ({label_target}): {target_case_count:,}")
        logger.info(f"  ED_NON_OPIOID target patients ({label_ed_non_opioid}): {ed_non_opioid_case_count:,}")
        
        if target_case_count == 0:
            logger.warning(f"⚠️ [PHASE 3 STEP 3] WARNING: No target cases found for OPIOID_ED cohort ({label_target})")
            logger.warning(f"   Cohort will be empty and will not be saved to S3")
            logger.warning(f"   Check: Are target ICD codes present in {age_band}/{event_year}?")
        
        if ed_non_opioid_case_count == 0:
            logger.warning(f"⚠️ [PHASE 3 STEP 3] WARNING: No target cases found for ED_NON_OPIOID cohort ({label_ed_non_opioid})")
            logger.warning(f"   Will create control-only cohort for model training consistency")
        
        # Load pre-computed average target count for control-only cohorts
        # This avoids recalculating averages at runtime for each partition
        # Config is generated by step1_pre_cohort_audit.py and saved to S3 and local file
        avg_target_count = None
        if target_case_count == 0 or ed_non_opioid_case_count == 0:
            import json
            import boto3
            
            # Try loading from local config file first (faster)
            config_file = os.path.join(os.path.dirname(__file__), '..', '..', 'cohort_target_averages.json')
            config = None
            
            try:
                if os.path.exists(config_file):
                    with open(config_file, 'r') as f:
                        config = json.load(f)
                    logger.info(f"→ [PHASE 3 STEP 3] Loaded pre-computed averages from local config")
                else:
                    # Try loading from S3 if local file doesn't exist
                    logger.info(f"→ [PHASE 3 STEP 3] Local config not found, trying S3...")
                    s3_path = f"s3://{S3_BUCKET}/gold/qa_results/pre_cohort_audit/target_averages.json"
                    try:
                        s3_client = boto3.client('s3')
                        bucket = S3_BUCKET
                        key = "gold/qa_results/pre_cohort_audit/target_averages.json"
                        response = s3_client.get_object(Bucket=bucket, Key=key)
                        config = json.loads(response['Body'].read().decode('utf-8'))
                        logger.info(f"→ [PHASE 3 STEP 3] Loaded pre-computed averages from S3")
                        # Save locally for future use
                        try:
                            with open(config_file, 'w') as f:
                                json.dump(config, f, indent=2)
                            logger.info(f"→ [PHASE 3 STEP 3] Saved S3 config to local file for future use")
                        except Exception:
                            pass
                    except Exception as s3_e:
                        logger.warning(f"⚠️ Could not load from S3: {s3_e}")
                        logger.warning(f"   Run step1_pre_cohort_audit.py --save-results first")
            except Exception as e:
                logger.warning(f"⚠️ Could not load pre-computed averages: {e}")
                config = None
            
            # Extract average from config
            if config and 'averages' in config and 'combined' in config['averages']:
                avg_target_count = int(config['averages']['combined']['average'])
                logger.info(f"→ [PHASE 3 STEP 3] Using pre-computed average combined targets: {avg_target_count:,}")
            else:
                # Fallback to reasonable default if config not available
                avg_target_count = 1000  # Default fallback
                logger.warning(f"⚠️ [PHASE 3 STEP 3] Using fallback average target count: {avg_target_count:,}")
                logger.warning(f"   Run step1_pre_cohort_audit.py --save-results to generate proper averages")
        
        # Create OPIOID_ED cohort with 5:1 control-to-target ratio
        # If no targets, create control-only cohort using average target count
        if target_case_count > 0:
            # Normal case: has targets
            # Calculate first target event dates and days_to_target_event
            opioid_ed_cohort_sql = f"""
            CREATE OR REPLACE VIEW opioid_ed_cohort AS
            WITH target_cases AS (
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE event_classification = '{label_target}'
            ),
            first_target_dates AS (
                -- Find first target event date per patient
                SELECT 
                    mi_person_key,
                    MIN(event_date) as first_opioid_ed_date
                FROM unified_event_fact_table
                WHERE event_classification = '{label_target}'
                GROUP BY mi_person_key
            ),
            control_candidates AS (
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE event_classification != '{label_target}'
                  AND mi_person_key NOT IN (SELECT mi_person_key FROM target_cases)
            ),
            sampled_controls AS (
                -- Sample distinct controls only (no reuse WITHIN this cohort to maintain statistical independence)
                -- NOTE: Same controls CAN be reused ACROSS cohorts (OPIOID_ED vs ED_NON_OPIOID) as they are independent studies
                -- Use all available controls if fewer than 5:1 ratio (expected only for small partitions)
                -- Should achieve 5:1 ratio unless partition (age_band + event_year) is genuinely small
                WITH target_count AS (
                    SELECT COUNT(*) as target_cnt FROM target_cases
                ),
                needed_count AS (
                    SELECT tc.target_cnt * 5 as needed FROM target_count tc
                ),
                available_controls AS (
                    SELECT COUNT(*) as available FROM control_candidates
                )
                SELECT 
                    mi_person_key
                FROM control_candidates
                ORDER BY RANDOM()
                LIMIT (
                    SELECT LEAST(
                        (SELECT needed FROM needed_count),
                        (SELECT available FROM available_controls)
                    )
                )
            )
            SELECT 
                uef.*,
                1 as target,
                'OPIOID_ED' as cohort_name,
                CASE 
                    WHEN tc.mi_person_key IS NOT NULL THEN 'OPIOID_ED'
                    ELSE 'NON_ED'
                END as cohort,
                CASE WHEN tc.mi_person_key IS NOT NULL THEN 1 ELSE 0 END as is_target_case,
                -- Ensure all columns match: controls get NULL for target-specific fields
                CASE 
                    WHEN tc.mi_person_key IS NOT NULL THEN ftd.first_opioid_ed_date
                    ELSE NULL
                END as first_opioid_ed_date,
                NULL as first_ed_non_opioid_date,
                NULL as days_to_target_event  -- Not needed for opioid_ed; can be calculated from event_date and first_opioid_ed_date
            FROM unified_event_fact_table uef
            LEFT JOIN target_cases tc ON uef.mi_person_key = tc.mi_person_key
            LEFT JOIN sampled_controls sc ON uef.mi_person_key = sc.mi_person_key
            LEFT JOIN first_target_dates ftd ON uef.mi_person_key = ftd.mi_person_key
            WHERE tc.mi_person_key IS NOT NULL OR sc.mi_person_key IS NOT NULL;
            """
        else:
            # Zero targets: create control-only cohort
            logger.info(f"→ [PHASE 3 STEP 3] Creating control-only OPIOID_ED cohort (no targets found)")
            control_limit = avg_target_count * 5 if avg_target_count else 5000  # Default 5000 controls
            opioid_ed_cohort_sql = f"""
            CREATE OR REPLACE VIEW opioid_ed_cohort AS
            WITH control_candidates AS (
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE event_classification != '{label_target}'
            ),
            sampled_controls AS (
                SELECT mi_person_key
                FROM control_candidates
                ORDER BY RANDOM()
                LIMIT {control_limit}
            )
            SELECT 
                uef.*,
                0 as target,  -- All controls, no targets
                'OPIOID_ED' as cohort_name,
                'NON_ED' as cohort,  -- All controls are non-ED
                0 as is_target_case,  -- All are controls
                -- No target dates for control-only cohort
                NULL as first_opioid_ed_date,
                NULL as first_ed_non_opioid_date,
                NULL as days_to_target_event
            FROM unified_event_fact_table uef
            INNER JOIN sampled_controls sc ON uef.mi_person_key = sc.mi_person_key;
            """
        execute_sql_with_dev_validation(cohort_conn_duckdb, logger, opioid_ed_cohort_sql)
        logger.info("→ [PHASE 3 STEP 3] OPIOID_ED cohort created")
        
        # Create ED_NON_OPIOID cohort with 5:1 control-to-target ratio
        # Target cases are HCG-based ED visits (always classified as 'ed_non_opioid')
        # EXCLUDE patients with opioid ICD codes (F1120, etc.) from target cases
        # If no targets, create control-only cohort using average target count
        if ed_non_opioid_case_count > 0:
            # Normal case: has targets
            # Exclude patients who have opioid ICD codes from ED_NON_OPIOID target cases
            # Apply 30-day lookback window for drug events (per README documentation)
            from helpers_1997_13.constants import OPIOID_ICD_CODES
            ed_non_opioid_cohort_sql = f"""
            CREATE OR REPLACE VIEW ed_non_opioid_cohort AS
            WITH opioid_patients AS (
                -- Patients with opioid ICD codes (F1120, etc.) - exclude from ED_NON_OPIOID targets
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE primary_icd_diagnosis_code IN {tuple(OPIOID_ICD_CODES)}
            ),
            target_cases AS (
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE event_classification = '{label_ed_non_opioid}'
                  AND mi_person_key NOT IN (SELECT mi_person_key FROM opioid_patients)
            ),
            first_target_dates AS (
                -- Find first ED_NON_OPIOID target event date per patient
                SELECT 
                    mi_person_key,
                    MIN(event_date) as first_ed_non_opioid_date
                FROM unified_event_fact_table
                WHERE event_classification = '{label_ed_non_opioid}'
                  AND mi_person_key NOT IN (SELECT mi_person_key FROM opioid_patients)
                GROUP BY mi_person_key
            ),
            control_candidates AS (
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE event_classification != '{label_ed_non_opioid}'
                  AND mi_person_key NOT IN (SELECT mi_person_key FROM target_cases)
                  AND mi_person_key NOT IN (SELECT mi_person_key FROM opioid_patients)
                  -- Exclude opioid patients from controls as well - complete separation
            ),
            sampled_controls AS (
                -- Sample distinct controls only (no reuse WITHIN this cohort to maintain statistical independence)
                -- NOTE: Same controls CAN be reused ACROSS cohorts (OPIOID_ED vs ED_NON_OPIOID) as they are independent studies
                -- Use all available controls if fewer than 5:1 ratio (expected only for small partitions)
                -- Should achieve 5:1 ratio unless partition (age_band + event_year) is genuinely small
                WITH target_count AS (
                    SELECT COUNT(*) as target_cnt FROM target_cases
                ),
                needed_count AS (
                    SELECT tc.target_cnt * 5 as needed FROM target_count tc
                ),
                available_controls AS (
                    SELECT COUNT(*) as available FROM control_candidates
                )
                SELECT 
                    mi_person_key
                FROM control_candidates
                ORDER BY RANDOM()
                LIMIT (
                    SELECT LEAST(
                        (SELECT needed FROM needed_count),
                        (SELECT available FROM available_controls)
                    )
                )
            ),
            control_reference_dates AS (
                -- For controls, use first non-ED medical event as reference date (similar to target date for cases)
                -- This ensures balanced temporal windows between targets and controls
                -- Fallback to first medical event if no non-ED medical events exist
                WITH non_ed_reference AS (
                    SELECT 
                        uef.mi_person_key,
                        MIN(uef.event_date) as reference_date
                    FROM unified_event_fact_table uef
                    INNER JOIN sampled_controls sc ON uef.mi_person_key = sc.mi_person_key
                    WHERE uef.event_type = 'medical'
                      AND (uef.hcg_line IS NULL OR uef.hcg_line NOT IN ('P51 - ER Visits and Observation Care', 'O11 - Emergency Room', 'P33 - Urgent Care Visits'))
                    GROUP BY uef.mi_person_key
                ),
                fallback_reference AS (
                    SELECT 
                        uef.mi_person_key,
                        MIN(uef.event_date) as reference_date
                    FROM unified_event_fact_table uef
                    INNER JOIN sampled_controls sc ON uef.mi_person_key = sc.mi_person_key
                    WHERE uef.event_type = 'medical'
                      AND uef.mi_person_key NOT IN (SELECT mi_person_key FROM non_ed_reference)
                    GROUP BY uef.mi_person_key
                )
                SELECT * FROM non_ed_reference
                UNION ALL
                SELECT * FROM fallback_reference
            ),
            events_with_dates AS (
                -- Calculate days_to_target_event for all events
                -- For targets: days to first ED_NON_OPIOID event
                -- For controls: days to reference date (first non-ED medical event) to balance temporal windows
                SELECT 
                    uef.*,
                    ftd.first_ed_non_opioid_date,
                    crd.reference_date as control_reference_date,
                    -- Calculate days_to_target_event
                    -- For targets: days to first target event
                    -- For controls: days to reference date (to balance temporal windows)
                    CASE 
                        WHEN ftd.first_ed_non_opioid_date IS NOT NULL AND uef.event_date IS NOT NULL
                        THEN CAST(datediff(ftd.first_ed_non_opioid_date::DATE, uef.event_date::DATE) AS INTEGER)
                        WHEN crd.reference_date IS NOT NULL AND uef.event_date IS NOT NULL
                        THEN CAST(datediff(crd.reference_date::DATE, uef.event_date::DATE) AS INTEGER)
                        ELSE NULL
                    END as days_to_target_event
                FROM unified_event_fact_table uef
                LEFT JOIN first_target_dates ftd ON uef.mi_person_key = ftd.mi_person_key
                LEFT JOIN control_reference_dates crd ON uef.mi_person_key = crd.mi_person_key
            )
            SELECT 
                ewd.*,
                1 as target,
                'ED_NON_OPIOID' as cohort_name,
                CASE 
                    WHEN tc.mi_person_key IS NOT NULL THEN 'NON_OPIOID_ED'
                    WHEN ewd.event_type = 'medical' AND ewd.hcg_line IS NULL THEN 'NON_ED'
                    ELSE 'NON_ED'
                END as cohort,
                CASE WHEN tc.mi_person_key IS NOT NULL THEN 1 ELSE 0 END as is_target_case,
                -- Ensure all columns match: controls get NULL for target-specific fields
                NULL as first_opioid_ed_date,
                CASE 
                    WHEN tc.mi_person_key IS NOT NULL THEN ewd.first_ed_non_opioid_date
                    ELSE NULL
                END as first_ed_non_opioid_date
            FROM events_with_dates ewd
            LEFT JOIN target_cases tc ON ewd.mi_person_key = tc.mi_person_key
            LEFT JOIN sampled_controls sc ON ewd.mi_person_key = sc.mi_person_key
            WHERE (tc.mi_person_key IS NOT NULL OR sc.mi_person_key IS NOT NULL)
              -- Apply balanced 30-day lookback window to both targets and controls
              -- For target cases: medical events OR drug events within 30 days before target
              -- For controls: medical events OR drug events within 30 days before reference date
              AND (
                  -- Target cases: include medical events OR drug events within 30 days before target
                  (tc.mi_person_key IS NOT NULL AND (
                      ewd.event_type = 'medical' 
                      OR (ewd.event_type = 'pharmacy' AND ewd.days_to_target_event IS NOT NULL 
                          AND ewd.days_to_target_event >= 0 AND ewd.days_to_target_event <= 30)
                  ))
                  -- Controls: apply same temporal logic for balanced comparison
                  OR (sc.mi_person_key IS NOT NULL AND (
                      ewd.event_type = 'medical'
                      OR (ewd.event_type = 'pharmacy' AND ewd.days_to_target_event IS NOT NULL 
                          AND ewd.days_to_target_event >= 0 AND ewd.days_to_target_event <= 30)
                  ))
              );
            """
        else:
            # Zero targets: create control-only cohort
            logger.info(f"→ [PHASE 3 STEP 3] Creating control-only ED_NON_OPIOID cohort (no targets found)")
            control_limit = avg_target_count * 5 if avg_target_count else 5000  # Default 5000 controls
            # Exclude opioid patients from controls as well
            from helpers_1997_13.constants import OPIOID_ICD_CODES
            ed_non_opioid_cohort_sql = f"""
            CREATE OR REPLACE VIEW ed_non_opioid_cohort AS
            WITH opioid_patients AS (
                -- Patients with opioid ICD codes (F1120, etc.) - exclude from ED_NON_OPIOID entirely
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE primary_icd_diagnosis_code IN {tuple(OPIOID_ICD_CODES)}
            ),
            control_candidates AS (
                SELECT DISTINCT mi_person_key
                FROM unified_event_fact_table
                WHERE event_classification != '{label_ed_non_opioid}'
                  AND mi_person_key NOT IN (SELECT mi_person_key FROM opioid_patients)
            ),
            sampled_controls AS (
                SELECT mi_person_key
                FROM control_candidates
                ORDER BY RANDOM()
                LIMIT {control_limit}
            )
             SELECT 
                 uef.*,
                 0 as target,  -- All controls, no targets
                 'ED_NON_OPIOID' as cohort_name,
                 'NON_ED' as cohort,  -- All controls are non-ED
                 0 as is_target_case,  -- All are controls
                 -- No target dates for control-only cohort
                 NULL as first_opioid_ed_date,
                 NULL as first_ed_non_opioid_date,
                 NULL as days_to_target_event
             FROM unified_event_fact_table uef
            INNER JOIN sampled_controls sc ON uef.mi_person_key = sc.mi_person_key;
            """
        execute_sql_with_dev_validation(cohort_conn_duckdb, logger, ed_non_opioid_cohort_sql)
        logger.info("→ [PHASE 3 STEP 3] ED_NON_OPIOID cohort created")
        
        # Log drug window statistics for ed_non_opioid cohort
        if ed_non_opioid_case_count > 0:
            try:
                drug_window_stats = cohort_conn_duckdb.sql("""
                SELECT 
                    COUNT(*) as total_drug_events,
                    COUNT(DISTINCT mi_person_key) as patients_with_drugs,
                    COUNT(CASE WHEN days_to_target_event IS NOT NULL AND days_to_target_event >= 0 AND days_to_target_event <= 30 THEN 1 END) as drugs_in_30day_window,
                    AVG(CASE WHEN days_to_target_event IS NOT NULL AND days_to_target_event >= 0 AND days_to_target_event <= 30 THEN days_to_target_event END) as avg_days_in_window
                FROM ed_non_opioid_cohort
                WHERE event_type = 'pharmacy' AND is_target_case = 1
                """).fetchone()
                if drug_window_stats and drug_window_stats[0] > 0:
                    logger.info(f"→ [PHASE 3 STEP 3] ED_NON_OPIOID Drug Window Stats (target cases):")
                    logger.info(f"  Total drug events: {drug_window_stats[0]:,}")
                    logger.info(f"  Patients with drugs: {drug_window_stats[1]:,}")
                    logger.info(f"  Drugs in 30-day window: {drug_window_stats[2]:,}")
                    if drug_window_stats[3]:
                        logger.info(f"  Avg days in window: {drug_window_stats[3]:.1f}")
            except Exception as e:
                logger.debug(f"Could not calculate drug window stats: {e}")
        
        # QA checks
        opioid_ed_count = cohort_conn_duckdb.sql("SELECT COUNT(*) FROM opioid_ed_cohort").fetchone()[0]
        ed_non_opioid_count = cohort_conn_duckdb.sql("SELECT COUNT(*) FROM ed_non_opioid_cohort").fetchone()[0]
        
        # Check control ratios
        opioid_ed_ratio = cohort_conn_duckdb.sql("""
        SELECT 
            COUNT(DISTINCT CASE WHEN is_target_case = 1 THEN mi_person_key END) as target_cases,
            COUNT(DISTINCT CASE WHEN is_target_case = 0 THEN mi_person_key END) as control_cases
        FROM opioid_ed_cohort
        """).fetchone()
        
        ed_non_opioid_ratio = cohort_conn_duckdb.sql("""
        SELECT 
            COUNT(DISTINCT CASE WHEN is_target_case = 1 THEN mi_person_key END) as target_cases,
            COUNT(DISTINCT CASE WHEN is_target_case = 0 THEN mi_person_key END) as control_cases
        FROM ed_non_opioid_cohort
        """).fetchone()
        
        opioid_ed_control_ratio = opioid_ed_ratio[1] / opioid_ed_ratio[0] if opioid_ed_ratio[0] > 0 else 0
        ed_non_opioid_control_ratio = ed_non_opioid_ratio[1] / ed_non_opioid_ratio[0] if ed_non_opioid_ratio[0] > 0 else 0
        
        logger.info(f"→ [PHASE 3 STEP 3] QA: OPIOID_ED records: {opioid_ed_count:,}")
        logger.info(f"→ [PHASE 3 STEP 3] QA: ED_NON_OPIOID records: {ed_non_opioid_count:,}")
        logger.info(f"→ [PHASE 3 STEP 3] QA: OPIOID_ED control ratio: {opioid_ed_control_ratio:.2f}:1")
        logger.info(f"→ [PHASE 3 STEP 3] QA: ED_NON_OPIOID control ratio: {ed_non_opioid_control_ratio:.2f}:1")
        
        # Warn if ratio is below 5:1 (expected only for small partitions: age_band + event_year)
        # This should rarely occur unless the partition is genuinely small
        if opioid_ed_ratio[0] > 0 and opioid_ed_control_ratio < 5.0:
            logger.warning(
                f"⚠️ [PHASE 3 STEP 3] OPIOID_ED cohort has control ratio {opioid_ed_control_ratio:.2f}:1 "
                f"(target: 5:1). This is expected for small partitions ({age_band}/{event_year}). "
                f"All available controls used: Target cases: {opioid_ed_ratio[0]:,}, Control cases: {opioid_ed_ratio[1]:,}"
            )
        
        if ed_non_opioid_ratio[0] > 0 and ed_non_opioid_control_ratio < 5.0:
            logger.warning(
                f"⚠️ [PHASE 3 STEP 3] ED_NON_OPIOID cohort has control ratio {ed_non_opioid_control_ratio:.2f}:1 "
                f"(target: 5:1). This is expected for small partitions ({age_band}/{event_year}). "
                f"All available controls used: Target cases: {ed_non_opioid_ratio[0]:,}, Control cases: {ed_non_opioid_ratio[1]:,}"
            )
        
        # F1120-specific checks in cohorts
        f1120_opioid_check = cohort_conn_duckdb.sql("""
        SELECT 
            COUNT(*) as total_f1120_records,
            COUNT(DISTINCT mi_person_key) as distinct_f1120_patients,
            COUNT(DISTINCT CASE WHEN is_target_case = 1 THEN mi_person_key END) as f1120_target_patients,
            COUNT(DISTINCT CASE WHEN is_target_case = 0 THEN mi_person_key END) as f1120_control_patients
        FROM opioid_ed_cohort
        WHERE primary_icd_diagnosis_code = 'F1120'
        """).fetchone()
        
        f1120_ed_non_opioid_check = cohort_conn_duckdb.sql("""
        SELECT 
            COUNT(*) as total_f1120_records,
            COUNT(DISTINCT mi_person_key) as distinct_f1120_patients,
            COUNT(DISTINCT CASE WHEN is_target_case = 1 THEN mi_person_key END) as f1120_target_patients,
            COUNT(DISTINCT CASE WHEN is_target_case = 0 THEN mi_person_key END) as f1120_control_patients
        FROM ed_non_opioid_cohort
        WHERE primary_icd_diagnosis_code = 'F1120'
        """).fetchone()
        
        logger.info(f"→ [PHASE 3 STEP 3] F1120 IN OPIOID_ED COHORT:")
        logger.info(f"  Total F1120 records: {f1120_opioid_check[0]:,}")
        logger.info(f"  Distinct F1120 patients: {f1120_opioid_check[1]:,}")
        logger.info(f"  F1120 target patients: {f1120_opioid_check[2]:,}")
        logger.info(f"  F1120 control patients: {f1120_opioid_check[3]:,}")
        
        logger.info(f"→ [PHASE 3 STEP 3] F1120 IN ED_NON_OPIOID COHORT:")
        logger.info(f"  Total F1120 records: {f1120_ed_non_opioid_check[0]:,}")
        logger.info(f"  Distinct F1120 patients: {f1120_ed_non_opioid_check[1]:,}")
        logger.info(f"  F1120 target patients: {f1120_ed_non_opioid_check[2]:,}")
        logger.info(f"  F1120 control patients: {f1120_ed_non_opioid_check[3]:,}")
        
        # Force checkpoint
        force_checkpoint(cohort_conn_duckdb, logger)
        
        # Disable query profiling
        disable_query_profiling(cohort_conn_duckdb, logger)
        
        # Save checkpoint
        if pipeline_state:
            pipeline_state.mark_step_completed(step_name, {
                'opioid_ed_count': opioid_ed_count,
                'ed_non_opioid_count': ed_non_opioid_count,
                'opioid_ed_control_ratio': float(opioid_ed_control_ratio),
                'ed_non_opioid_control_ratio': float(ed_non_opioid_control_ratio),
                'timestamp': datetime.now().isoformat()
            })
        
        logger.info(f"{SYMBOLS['success']} [PHASE 3 STEP 3] Optimized final cohort creation completed")
        
    except Exception as e:
        logger.error(f"{SYMBOLS['fail']} [PHASE 3 STEP 3] Final cohort creation failed: {str(e)}")
        if pipeline_state:
            pipeline_state.mark_step_failed(step_name, str(e))
        cleanup_duckdb_temp_files(logger)
        raise

